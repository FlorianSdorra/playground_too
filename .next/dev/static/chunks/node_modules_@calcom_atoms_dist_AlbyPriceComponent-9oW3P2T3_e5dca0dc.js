(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@calcom/atoms/dist/AlbyPriceComponent-9oW3P2T3.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AlbyPriceComponent",
    ()=>wr
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$calcom$2f$atoms$2f$dist$2f$index$2d$d93whXsZ$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@calcom/atoms/dist/index-d93whXsZ.js [app-client] (ecmascript)");
;
;
;
const J = function(s, r = !0) {
    if (s.destroyed) throw new Error("Hash instance has been destroyed");
    if (r && s.finished) throw new Error("Hash#digest() has already been called");
}, or = (s)=>s instanceof Uint8Array, N = (s)=>new DataView(s.buffer, s.byteOffset, s.byteLength), L = (s, r)=>s << 32 - r | s >>> r;
if (new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] !== 68) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (s, r)=>r.toString(16).padStart(2, "0"));
function Z(s) {
    if (typeof s == "string" && (s = function(r) {
        if (typeof r != "string") throw new Error("utf8ToBytes expected string, got " + typeof r);
        return new Uint8Array(new TextEncoder().encode(r));
    }(s)), !or(s)) throw new Error("expected Uint8Array, got " + typeof s);
    return s;
}
class sr {
    clone() {
        return this._cloneInto();
    }
}
function q(s) {
    const r = (c)=>s().update(Z(c)).digest(), i = s();
    return r.outputLen = i.outputLen, r.blockLen = i.blockLen, r.create = ()=>s(), r;
}
class ir extends sr {
    constructor(r, i, c, f){
        super(), this.blockLen = r, this.outputLen = i, this.padOffset = c, this.isLE = f, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(r), this.view = N(this.buffer);
    }
    update(r) {
        J(this);
        const { view: i, buffer: c, blockLen: f } = this, u = (r = Z(r)).length;
        for(let l = 0; l < u;){
            const g = Math.min(f - this.pos, u - l);
            if (g !== f) c.set(r.subarray(l, l + g), this.pos), this.pos += g, l += g, this.pos === f && (this.process(i, 0), this.pos = 0);
            else {
                const m = N(r);
                for(; f <= u - l; l += f)this.process(m, l);
            }
        }
        return this.length += r.length, this.roundClean(), this;
    }
    digestInto(r) {
        J(this), function(b, y) {
            (function(x, ...B) {
                if (!(x instanceof Uint8Array)) throw new Error("Expected Uint8Array");
                if (B.length > 0 && !B.includes(x.length)) throw new Error(`Expected Uint8Array of length ${B}, not of length=${x.length}`);
            })(b);
            const E = y.outputLen;
            if (b.length < E) throw new Error(`digestInto() expects output buffer of length at least ${E}`);
        }(r, this), this.finished = !0;
        const { buffer: i, view: c, blockLen: f, isLE: u } = this;
        let { pos: l } = this;
        i[l++] = 128, this.buffer.subarray(l).fill(0), this.padOffset > f - l && (this.process(c, 0), l = 0);
        for(let b = l; b < f; b++)i[b] = 0;
        (function(b, y, E, x) {
            if (typeof b.setBigUint64 == "function") return b.setBigUint64(y, E, x);
            const B = BigInt(32), k = BigInt(4294967295), _ = Number(E >> B & k), C = Number(E & k), j = x ? 0 : 4;
            b.setUint32(y + (x ? 4 : 0), _, x), b.setUint32(y + j, C, x);
        })(c, f - 8, BigInt(8 * this.length), u), this.process(c, 0);
        const g = N(r), m = this.outputLen;
        if (m % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const U = m / 4, A = this.get();
        if (U > A.length) throw new Error("_sha2: outputLen bigger than state");
        for(let b = 0; b < U; b++)g.setUint32(4 * b, A[b], u);
    }
    digest() {
        const { buffer: r, outputLen: i } = this;
        this.digestInto(r);
        const c = r.slice(0, i);
        return this.destroy(), c;
    }
    _cloneInto(r) {
        r || (r = new this.constructor()), r.set(...this.get());
        const { blockLen: i, buffer: c, length: f, finished: u, destroyed: l, pos: g } = this;
        return r.length = f, r.pos = g, r.finished = u, r.destroyed = l, f % i && r.buffer.set(c), r;
    }
}
const ar = (s, r, i)=>s & r ^ s & i ^ r & i, cr = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), I = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), T = new Uint32Array(64);
class rr extends ir {
    constructor(){
        super(64, 32, 8, !1), this.A = 0 | I[0], this.B = 0 | I[1], this.C = 0 | I[2], this.D = 0 | I[3], this.E = 0 | I[4], this.F = 0 | I[5], this.G = 0 | I[6], this.H = 0 | I[7];
    }
    get() {
        const { A: r, B: i, C: c, D: f, E: u, F: l, G: g, H: m } = this;
        return [
            r,
            i,
            c,
            f,
            u,
            l,
            g,
            m
        ];
    }
    set(r, i, c, f, u, l, g, m) {
        this.A = 0 | r, this.B = 0 | i, this.C = 0 | c, this.D = 0 | f, this.E = 0 | u, this.F = 0 | l, this.G = 0 | g, this.H = 0 | m;
    }
    process(r, i) {
        for(let y = 0; y < 16; y++, i += 4)T[y] = r.getUint32(i, !1);
        for(let y = 16; y < 64; y++){
            const E = T[y - 15], x = T[y - 2], B = L(E, 7) ^ L(E, 18) ^ E >>> 3, k = L(x, 17) ^ L(x, 19) ^ x >>> 10;
            T[y] = k + T[y - 7] + B + T[y - 16] | 0;
        }
        let { A: c, B: f, C: u, D: l, E: g, F: m, G: U, H: A } = this;
        for(let y = 0; y < 64; y++){
            const E = A + (L(g, 6) ^ L(g, 11) ^ L(g, 25)) + ((b = g) & m ^ ~b & U) + cr[y] + T[y] | 0, x = (L(c, 2) ^ L(c, 13) ^ L(c, 22)) + ar(c, f, u) | 0;
            A = U, U = m, m = g, g = l + E | 0, l = u, u = f, f = c, c = E + x | 0;
        }
        var b;
        c = c + this.A | 0, f = f + this.B | 0, u = u + this.C | 0, l = l + this.D | 0, g = g + this.E | 0, m = m + this.F | 0, U = U + this.G | 0, A = A + this.H | 0, this.set(c, f, u, l, g, m, U, A);
    }
    roundClean() {
        T.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}
class hr extends rr {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
}
q(()=>new rr());
q(()=>new hr());
var K, R;
K = function(s, r) {
    function i(e) {
        if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`);
    }
    function c(...e) {
        const t = (n, o)=>(a)=>n(o(a));
        return {
            encode: Array.from(e).reverse().reduce((n, o)=>n ? t(n, o.encode) : o.encode, void 0),
            decode: e.reduce((n, o)=>n ? t(n, o.decode) : o.decode, void 0)
        };
    }
    function f(e) {
        return {
            encode: (t)=>{
                if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
                return t.map((n)=>{
                    if (i(n), n < 0 || n >= e.length) throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${e.length})`);
                    return e[n];
                });
            },
            decode: (t)=>{
                if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("alphabet.decode input should be array of strings");
                return t.map((n)=>{
                    if (typeof n != "string") throw new Error(`alphabet.decode: not string element=${n}`);
                    const o = e.indexOf(n);
                    if (o === -1) throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);
                    return o;
                });
            }
        };
    }
    function u(e = "") {
        if (typeof e != "string") throw new Error("join separator should be string");
        return {
            encode: (t)=>{
                if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("join.encode input should be array of strings");
                for (let n of t)if (typeof n != "string") throw new Error(`join.encode: non-string input=${n}`);
                return t.join(e);
            },
            decode: (t)=>{
                if (typeof t != "string") throw new Error("join.decode input should be string");
                return t.split(e);
            }
        };
    }
    function l(e, t = "=") {
        if (i(e), typeof t != "string") throw new Error("padding chr should be string");
        return {
            encode (n) {
                if (!Array.isArray(n) || n.length && typeof n[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let o of n)if (typeof o != "string") throw new Error(`padding.encode: non-string input=${o}`);
                for(; n.length * e % 8;)n.push(t);
                return n;
            },
            decode (n) {
                if (!Array.isArray(n) || n.length && typeof n[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let a of n)if (typeof a != "string") throw new Error(`padding.decode: non-string input=${a}`);
                let o = n.length;
                if (o * e % 8) throw new Error("Invalid padding: string should have whole number of bytes");
                for(; o > 0 && n[o - 1] === t; o--)if (!((o - 1) * e % 8)) throw new Error("Invalid padding: string has too much padding");
                return n.slice(0, o);
            }
        };
    }
    function g(e) {
        if (typeof e != "function") throw new Error("normalize fn should be function");
        return {
            encode: (t)=>t,
            decode: (t)=>e(t)
        };
    }
    function m(e, t, n) {
        if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
        if (n < 2) throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);
        if (!Array.isArray(e)) throw new Error("convertRadix: data should be array");
        if (!e.length) return [];
        let o = 0;
        const a = [], h = Array.from(e);
        for(h.forEach((d)=>{
            if (i(d), d < 0 || d >= t) throw new Error(`Wrong integer: ${d}`);
        });;){
            let d = 0, w = !0;
            for(let p = o; p < h.length; p++){
                const $ = h[p], v = t * d + $;
                if (!Number.isSafeInteger(v) || t * d / t !== d || v - $ != t * d) throw new Error("convertRadix: carry overflow");
                if (d = v % n, h[p] = Math.floor(v / n), !Number.isSafeInteger(h[p]) || h[p] * n + d !== v) throw new Error("convertRadix: carry overflow");
                w && (h[p] ? w = !1 : o = p);
            }
            if (a.push(d), w) break;
        }
        for(let d = 0; d < e.length - 1 && e[d] === 0; d++)a.push(0);
        return a.reverse();
    }
    Object.defineProperty(r, "__esModule", {
        value: !0
    }), r.bytes = r.stringToBytes = r.str = r.bytesToString = r.hex = r.utf8 = r.bech32m = r.bech32 = r.base58check = r.base58xmr = r.base58xrp = r.base58flickr = r.base58 = r.base64url = r.base64 = r.base32crockford = r.base32hex = r.base32 = r.base16 = r.utils = r.assertNumber = void 0, r.assertNumber = i;
    const U = (e, t)=>t ? U(t, e % t) : e, A = (e, t)=>e + (t - U(e, t));
    function b(e, t, n, o) {
        if (!Array.isArray(e)) throw new Error("convertRadix2: data should be array");
        if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`);
        if (n <= 0 || n > 32) throw new Error(`convertRadix2: wrong to=${n}`);
        if (A(t, n) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${A(t, n)}`);
        let a = 0, h = 0;
        const d = 2 ** n - 1, w = [];
        for (const p of e){
            if (i(p), p >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${p} from=${t}`);
            if (a = a << t | p, h + t > 32) throw new Error(`convertRadix2: carry overflow pos=${h} from=${t}`);
            for(h += t; h >= n; h -= n)w.push((a >> h - n & d) >>> 0);
            a &= 2 ** h - 1;
        }
        if (a = a << n - h & d, !o && h >= t) throw new Error("Excess padding");
        if (!o && a) throw new Error(`Non-zero padding: ${a}`);
        return o && h > 0 && w.push(a >>> 0), w;
    }
    function y(e) {
        return i(e), {
            encode: (t)=>{
                if (!(t instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
                return m(Array.from(t), 256, e);
            },
            decode: (t)=>{
                if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("radix.decode input should be array of strings");
                return Uint8Array.from(m(t, e, 256));
            }
        };
    }
    function E(e, t = !1) {
        if (i(e), e <= 0 || e > 32) throw new Error("radix2: bits should be in (0..32]");
        if (A(8, e) > 32 || A(e, 8) > 32) throw new Error("radix2: carry overflow");
        return {
            encode: (n)=>{
                if (!(n instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
                return b(Array.from(n), 8, e, !t);
            },
            decode: (n)=>{
                if (!Array.isArray(n) || n.length && typeof n[0] != "number") throw new Error("radix2.decode input should be array of strings");
                return Uint8Array.from(b(n, e, 8, t));
            }
        };
    }
    function x(e) {
        if (typeof e != "function") throw new Error("unsafeWrapper fn should be function");
        return function(...t) {
            try {
                return e.apply(null, t);
            } catch  {}
        };
    }
    function B(e, t) {
        if (i(e), typeof t != "function") throw new Error("checksum fn should be function");
        return {
            encode (n) {
                if (!(n instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
                const o = t(n).slice(0, e), a = new Uint8Array(n.length + e);
                return a.set(n), a.set(o, n.length), a;
            },
            decode (n) {
                if (!(n instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
                const o = n.slice(0, -e), a = t(o).slice(0, e), h = n.slice(-e);
                for(let d = 0; d < e; d++)if (a[d] !== h[d]) throw new Error("Invalid checksum");
                return o;
            }
        };
    }
    r.utils = {
        alphabet: f,
        chain: c,
        checksum: B,
        radix: y,
        radix2: E,
        join: u,
        padding: l
    }, r.base16 = c(E(4), f("0123456789ABCDEF"), u("")), r.base32 = c(E(5), f("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), l(5), u("")), r.base32hex = c(E(5), f("0123456789ABCDEFGHIJKLMNOPQRSTUV"), l(5), u("")), r.base32crockford = c(E(5), f("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), u(""), g((e)=>e.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), r.base64 = c(E(6), f("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), l(6), u("")), r.base64url = c(E(6), f("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), l(6), u(""));
    const k = (e)=>c(y(58), f(e), u(""));
    r.base58 = k("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), r.base58flickr = k("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), r.base58xrp = k("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const _ = [
        0,
        2,
        3,
        5,
        6,
        7,
        9,
        10,
        11
    ];
    r.base58xmr = {
        encode (e) {
            let t = "";
            for(let n = 0; n < e.length; n += 8){
                const o = e.subarray(n, n + 8);
                t += r.base58.encode(o).padStart(_[o.length], "1");
            }
            return t;
        },
        decode (e) {
            let t = [];
            for(let n = 0; n < e.length; n += 11){
                const o = e.slice(n, n + 11), a = _.indexOf(o.length), h = r.base58.decode(o);
                for(let d = 0; d < h.length - a; d++)if (h[d] !== 0) throw new Error("base58xmr: wrong padding");
                t = t.concat(Array.from(h.slice(h.length - a)));
            }
            return Uint8Array.from(t);
        }
    }, r.base58check = (e)=>c(B(4, (t)=>e(e(t))), r.base58);
    const C = c(f("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), u("")), j = [
        996825010,
        642813549,
        513874426,
        1027748829,
        705979059
    ];
    function S(e) {
        const t = e >> 25;
        let n = (33554431 & e) << 5;
        for(let o = 0; o < j.length; o++)(t >> o & 1) == 1 && (n ^= j[o]);
        return n;
    }
    function H(e, t, n = 1) {
        const o = e.length;
        let a = 1;
        for(let h = 0; h < o; h++){
            const d = e.charCodeAt(h);
            if (d < 33 || d > 126) throw new Error(`Invalid prefix (${e})`);
            a = S(a) ^ d >> 5;
        }
        a = S(a);
        for(let h = 0; h < o; h++)a = S(a) ^ 31 & e.charCodeAt(h);
        for (let h of t)a = S(a) ^ h;
        for(let h = 0; h < 6; h++)a = S(a);
        return a ^= n, C.encode(b([
            a % 2 ** 30
        ], 30, 5, !1));
    }
    function O(e) {
        const t = e === "bech32" ? 1 : 734539939, n = E(5), o = n.decode, a = n.encode, h = x(o);
        function d(w, p = 90) {
            if (typeof w != "string") throw new Error("bech32.decode input should be string, not " + typeof w);
            if (w.length < 8 || p !== !1 && w.length > p) throw new TypeError(`Wrong string length: ${w.length} (${w}). Expected (8..${p})`);
            const $ = w.toLowerCase();
            if (w !== $ && w !== w.toUpperCase()) throw new Error("String must be lowercase or uppercase");
            const v = (w = $).lastIndexOf("1");
            if (v === 0 || v === -1) throw new Error('Letter "1" must be present between prefix and data only');
            const G = w.slice(0, v), D = w.slice(v + 1);
            if (D.length < 6) throw new Error("Data must be at least 6 characters long");
            const M = C.decode(D).slice(0, -6), P = H(G, M, t);
            if (!D.endsWith(P)) throw new Error(`Invalid checksum in ${w}: expected "${P}"`);
            return {
                prefix: G,
                words: M
            };
        }
        return {
            encode: function(w, p, $ = 90) {
                if (typeof w != "string") throw new Error("bech32.encode prefix should be string, not " + typeof w);
                if (!Array.isArray(p) || p.length && typeof p[0] != "number") throw new Error("bech32.encode words should be array of numbers, not " + typeof p);
                const v = w.length + 7 + p.length;
                if ($ !== !1 && v > $) throw new TypeError(`Length ${v} exceeds limit ${$}`);
                return `${w = w.toLowerCase()}1${C.encode(p)}${H(w, p, t)}`;
            },
            decode: d,
            decodeToBytes: function(w) {
                const { prefix: p, words: $ } = d(w, !1);
                return {
                    prefix: p,
                    words: $,
                    bytes: o($)
                };
            },
            decodeUnsafe: x(d),
            fromWords: o,
            fromWordsUnsafe: h,
            toWords: a
        };
    }
    r.bech32 = O("bech32"), r.bech32m = O("bech32m"), r.utf8 = {
        encode: (e)=>new TextDecoder().decode(e),
        decode: (e)=>new TextEncoder().encode(e)
    }, r.hex = c(E(4), f("0123456789abcdef"), u(""), g((e)=>{
        if (typeof e != "string" || e.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
        return e.toLowerCase();
    }));
    const F = {
        utf8: r.utf8,
        hex: r.hex,
        base16: r.base16,
        base32: r.base32,
        base64: r.base64,
        base64url: r.base64url,
        base58: r.base58,
        base58xmr: r.base58xmr
    }, W = `Invalid encoding type. Available types: ${Object.keys(F).join(", ")}`;
    r.bytesToString = (e, t)=>{
        if (typeof e != "string" || !F.hasOwnProperty(e)) throw new TypeError(W);
        if (!(t instanceof Uint8Array)) throw new TypeError("bytesToString() expects Uint8Array");
        return F[e].encode(t);
    }, r.str = r.bytesToString, r.stringToBytes = (e, t)=>{
        if (!F.hasOwnProperty(e)) throw new TypeError(W);
        if (typeof t != "string") throw new TypeError("stringToBytes() expects string");
        return F[e].decode(t);
    }, r.bytes = r.stringToBytes;
}, K(R = {
    exports: {}
}, R.exports), R.exports;
BigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);
BigInt("2100000000000000000");
BigInt(1e11);
const X = {
    payment_hash: 1,
    payment_secret: 16,
    description: 13,
    payee: 19,
    description_hash: 23,
    expiry: 6,
    min_final_cltv_expiry: 24,
    fallback_address: 9,
    route_hint: 3,
    feature_bits: 5,
    metadata: 27
};
for(let s = 0, r = Object.keys(X); s < r.length; s++)r[s], X[r[s]].toString();
const V = async (s)=>{
    const r = "https://getalby.com/api/rates/" + s.toLowerCase() + ".json";
    return (await (await fetch(r)).json()).rate_float / 1e8;
}, Y = async ({ satoshi: s, currency: r })=>{
    const i = await V(r);
    return Number(s) * i;
};
var fr = {
    __proto__: null,
    getFiatBtcRate: V,
    getFiatValue: Y,
    getSatoshiValue: async ({ amount: s, currency: r })=>{
        const i = await V(r);
        return Math.floor(Number(s) / i);
    },
    getFormattedFiatValue: async ({ satoshi: s, currency: r, locale: i })=>(i || (i = "en"), (await Y({
            satoshi: s,
            currency: r
        })).toLocaleString(i, {
            style: "currency",
            currency: r
        }))
};
function wr({ displaySymbol: s, price: r, formattedPrice: i }) {
    const [c, f] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState("loading...");
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "wr.useEffect": ()=>{
            ({
                "wr.useEffect": async ()=>{
                    const u = await fr.getFiatValue({
                        satoshi: r,
                        currency: "USD"
                    });
                    f(`$${u.toFixed(2)}`);
                }
            })["wr.useEffect"]();
        }
    }["wr.useEffect"], [
        r
    ]), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$calcom$2f$atoms$2f$dist$2f$index$2d$d93whXsZ$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Q"], {
        content: c,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("div", {
            className: "inline-flex items-center justify-center",
            children: [
                s && /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$calcom$2f$atoms$2f$dist$2f$index$2d$d93whXsZ$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["U"], {
                    className: "h-4 w-4"
                }),
                i
            ]
        })
    });
}
;
}),
]);

//# sourceMappingURL=node_modules_%40calcom_atoms_dist_AlbyPriceComponent-9oW3P2T3_e5dca0dc.js.map